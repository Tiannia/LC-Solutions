### 题目
[通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

### 描述
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

### 思路



### 题解
```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size();
        int m = p.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        //这部分考虑存在空串的情况：
        //1： 当s和p都为空串时，为true
        //2： 当s为空，p不空时，什么情况可以为true？p的前i个字符都为'*'时可以满足
        //3： 当s不空，p为空时，什么情况可以为true？都不可以，因为p为空是无法匹配s的
        dp[0][0] = 1;
        for(int i = 1; i <= m; ++i){
             if(p[i - 1] == '*'){
                 dp[0][i] = true;
             }else{
                 break;
             }
        }

        //那么，我们开始转移：
        //当s[i] == p[j] 或 p[j] == '?' 时，ok，我们两个消掉，让dp[i - 1][j - 1]的结果成为我们的答案吧
        //当p[j] == '*'时，出现了一种决策：选与不选（匹配or不匹配）？
        //1. 不进行匹配
        //       s:     abcd
        //       i:       ↑
        //       p:     abc*
        //       j:        ↑
        //ok，不选择，那就让dp[i][j - 1]成为我们的答案吧，为什么？因为既然进行不匹配的话，我就只能把'*'当成空串，是不是j指针就要减1呢
        //2. 进行匹配
        //       s:     abcd
        //       i:        ↑
        //       p:     abc*
        //       j:        ↑
        //ok，选择，那就让dp[i - 1][j]成为我们的答案吧，为什么？选择进行匹配，就意味着'*'会消去一个s中下标为i的字符，而我的'*'又能无限匹配，所以
        //i指针只能乖乖减去1，去看看以前的dp[i - 1][j]能不能进行匹配了。

        //因此啊，我们在选与不选之间决策出答案，背包问题是取最优值，在这里我全都要！
        
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= m; ++j){
                if(s[i - 1] == p[j - 1] || p[j - 1] == '?'){
                    dp[i][j] = dp[i - 1][j - 1];
                }
                if(p[j - 1]  == '*'){
                    dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
                }
            }
        }
        return dp[n][m];
    }
};
```
